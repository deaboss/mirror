<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Smart Mirror</title>
  <style>
    :root{
      --bg:#000;
      --fg:#fff;
      --grid:rgba(255,255,255,0.10);
      --axis:rgba(255,255,255,0.18);
      --text:rgba(255,255,255,0.88);
      --sub:rgba(255,255,255,0.72);
      --line:#fff;
      --line2:rgba(255,255,255,0.80);
      --line3:rgba(255,255,255,0.85);
    }
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"SF Pro Display","SF Pro Text","Helvetica Neue",Arial,sans-serif;
      overflow:hidden;
    }

    /* Left column that doesn't span the full screen */
    .wrap{
      height:100%;
      box-sizing:border-box;
      padding:28px;
      display:flex;
      align-items:flex-start;
      justify-content:flex-start;
    }
    .col{
      width:min(520px, 46vw);     /* limits overall width */
      max-width:520px;
      display:flex;
      flex-direction:column;
      align-items:flex-start;      /* hard left */
      gap:12px;
    }

    .clock{
      font-size:clamp(38px, 3.8vw, 58px);
      font-weight:600;
      line-height:1.05;
      letter-spacing:-0.02em;
      text-align:left;
    }
    .date{
      margin-top:6px;
      font-size:clamp(13px, 1.4vw, 17px);
      font-weight:500;
      color:var(--sub);
      text-align:left;
    }

    .weather{
      width:100%;
      display:flex;
      flex-direction:column;
      gap:6px;
      text-align:left;
    }
    .loc{
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      color:var(--sub);
    }
    .wxMain{
      font-size:clamp(15px, 1.7vw, 20px);
      font-weight:600;
      letter-spacing:-0.01em;
      line-height:1.2;
      color:var(--text);
    }
    .wxSub{
      font-size:13px;
      color:var(--sub);
    }

    .graph{
      width:100%;
      margin-top:6px;
    }
    .graphHeader{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:6px;
    }
    .graphLabel{
      font-size:11px;
      letter-spacing:0.10em;
      text-transform:uppercase;
      color:var(--sub);
    }
    .graphMeta{
      font-size:11px;
      color:rgba(255,255,255,0.55);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:55%;
      text-align:right;
    }

    /* Smaller graphs */
    svg{
      width:100%;
      height:78px;
      display:block;
    }

    /* Smaller satellite image, no border/box */
    .sat{
      width:100%;
      margin-top:6px;
    }
    .sat img{
      width:100%;
      height:240px;              /* fixed modest height */
      object-fit:cover;
      display:block;
      border-radius:12px;        /* optional; remove if you want perfectly square */
      opacity:0.92;
      filter:contrast(1.05) saturate(1.05);
    }

    /* If your screen is short, shrink image first */
    @media (max-height: 850px){
      svg{height:70px;}
      .sat img{height:200px;}
    }
    @media (max-height: 720px){
      svg{height:64px;}
      .sat img{display:none;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="col">
      <!-- Clock (top) -->
      <div>
        <div id="clock" class="clock">--:--</div>
        <div id="date" class="date">---</div>
      </div>

      <!-- Weather (directly under clock) -->
      <div class="weather">
        <div class="loc">San Luis Obispo, CA</div>
        <div id="wxMain" class="wxMain">Loading weather…</div>
        <div id="wxSub" class="wxSub"></div>
      </div>

      <!-- Graphs (no surrounding boxes) -->
      <div class="graph">
        <div class="graphHeader">
          <div class="graphLabel">Temperature (°F)</div>
          <div id="tempMeta" class="graphMeta"></div>
        </div>
        <svg id="tempSvg" viewBox="0 0 1000 170" preserveAspectRatio="none" aria-label="Temperature graph"></svg>
      </div>

      <div class="graph">
        <div class="graphHeader">
          <div class="graphLabel">Surface wind (mph)</div>
          <div id="windMeta" class="graphMeta"></div>
        </div>
        <svg id="windSvg" viewBox="0 0 1000 170" preserveAspectRatio="none" aria-label="Wind graph"></svg>
      </div>

      <div class="graph" id="rainWrap" style="display:none">
        <div class="graphHeader">
          <div class="graphLabel">Rain chance (%)</div>
          <div id="rainMeta" class="graphMeta"></div>
        </div>
        <svg id="rainSvg" viewBox="0 0 1000 170" preserveAspectRatio="none" aria-label="Rain chance graph"></svg>
      </div>

      <!-- Satellite (no box; constrained size) -->
      <div class="sat">
        <img id="satImg"
             alt="GOES-18 Satellite"
             src="https://cdn.star.nesdis.noaa.gov/GOES18/ABI/SECTOR/psw/GEOCOLOR/20260280201_GOES18-ABI-psw-GEOCOLOR-2400x2400.jpg" />
      </div>
    </div>
  </div>

  <script>
    const REFRESH_MINUTES = 5;

    // Coords from your NWS link
    const LAT = 35.2858;
    const LON = -120.6627;

    const HOURS_TO_PLOT = 24;

    const satBaseUrl =
      "https://cdn.star.nesdis.noaa.gov/GOES18/ABI/SECTOR/psw/GEOCOLOR/20260280201_GOES18-ABI-psw-GEOCOLOR-2400x2400.jpg";

    function pad2(n){ return String(n).padStart(2,"0"); }

    function updateClock(){
      const now = new Date();
      document.getElementById("clock").textContent = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
      document.getElementById("date").textContent = now.toLocaleDateString(undefined, {
        weekday:"long", year:"numeric", month:"long", day:"numeric"
      });
    }

    function bustSatelliteCache(){
      const img = document.getElementById("satImg");
      if (img) img.src = `${satBaseUrl}?t=${Date.now()}`;
    }

    function parseWindMph(windSpeedStr){
      if(!windSpeedStr) return null;
      const nums = windSpeedStr.match(/\d+/g);
      if(!nums || nums.length === 0) return null;
      const a = Number(nums[0]);
      if(nums.length >= 2){
        const b = Number(nums[1]);
        if(Number.isFinite(a) && Number.isFinite(b)) return (a + b) / 2;
      }
      return Number.isFinite(a) ? a : null;
    }

    function hourLabel(iso){
      const d = new Date(iso);
      const h = d.getHours();
      const hr = ((h + 11) % 12) + 1;
      const ap = h < 12 ? "a" : "p";
      return `${hr}${ap}`;
    }

    function svgEl(name){
      return document.createElementNS("http://www.w3.org/2000/svg", name);
    }

    function drawLineGraphWithAxes(svg, data, xLabels, ySuffix, stroke){
      const W=1000,H=170;
      const padL=64, padR=18, padT=14, padB=50;
      const innerW=W-padL-padR, innerH=H-padT-padB;

      svg.innerHTML = "";

      const clean = data.filter(v => Number.isFinite(v));
      if(clean.length < 2){
        const t = svgEl("text");
        t.setAttribute("x", W/2);
        t.setAttribute("y", H/2);
        t.setAttribute("fill", "#fff");
        t.setAttribute("opacity", "0.8");
        t.setAttribute("font-size", "18");
        t.setAttribute("text-anchor", "middle");
        t.textContent = "No data";
        svg.appendChild(t);
        return;
      }

      let min = Math.min(...clean);
      let max = Math.max(...clean);
      if(min === max){ min -= 1; max += 1; }

      // y ticks: min/mid/max (rounded nicely)
      const yTicks = [
        Math.round(min),
        Math.round((min + max) / 2),
        Math.round(max),
      ];

      yTicks.forEach(tv => {
        const y = padT + (1 - (tv - min) / (max - min)) * innerH;

        const gl = svgEl("line");
        gl.setAttribute("x1", padL);
        gl.setAttribute("x2", padL + innerW);
        gl.setAttribute("y1", y);
        gl.setAttribute("y2", y);
        gl.setAttribute("stroke", "rgba(255,255,255,0.10)");
        gl.setAttribute("stroke-width", "2");
        svg.appendChild(gl);

        const tx = svgEl("text");
        tx.setAttribute("x", padL - 10);
        tx.setAttribute("y", y + 6);
        tx.setAttribute("fill", "#fff");
        tx.setAttribute("opacity", "0.75");
        tx.setAttribute("font-size", "18");
        tx.setAttribute("text-anchor", "end");
        tx.textContent = `${tv}${ySuffix}`;
        svg.appendChild(tx);
      });

      // x axis
      const xAxis = svgEl("line");
      xAxis.setAttribute("x1", padL);
      xAxis.setAttribute("x2", padL + innerW);
      xAxis.setAttribute("y1", padT + innerH);
      xAxis.setAttribute("y2", padT + innerH);
      xAxis.setAttribute("stroke", "rgba(255,255,255,0.18)");
      xAxis.setAttribute("stroke-width", "2");
      svg.appendChild(xAxis);

      // x ticks/labels (6 labels)
      const labelCount = 6;
      const idxs = [];
      for(let i=0;i<labelCount;i++){
        const idx = Math.round(i * (xLabels.length - 1) / (labelCount - 1));
        if(!idxs.includes(idx)) idxs.push(idx);
      }

      idxs.forEach(idx => {
        const x = padL + (innerW * idx) / (data.length - 1);

        const tick = svgEl("line");
        tick.setAttribute("x1", x);
        tick.setAttribute("x2", x);
        tick.setAttribute("y1", padT + innerH);
        tick.setAttribute("y2", padT + innerH + 8);
        tick.setAttribute("stroke", "rgba(255,255,255,0.18)");
        tick.setAttribute("stroke-width", "2");
        svg.appendChild(tick);

        const tx = svgEl("text");
        tx.setAttribute("x", x);
        tx.setAttribute("y", padT + innerH + 30);
        tx.setAttribute("fill", "#fff");
        tx.setAttribute("opacity", "0.70");
        tx.setAttribute("font-size", "18");
        tx.setAttribute("text-anchor", "middle");
        tx.textContent = xLabels[idx] ?? "";
        svg.appendChild(tx);
      });

      // data path
      const xStep = innerW / (data.length - 1);
      let d = "";
      data.forEach((v,i)=>{
        const x = padL + xStep*i;
        const val = Number.isFinite(v) ? v : (i>0 ? data[i-1] : clean[0]);
        const y = padT + (1 - (val-min)/(max-min))*innerH;
        d += (i===0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
      });

      const path = svgEl("path");
      path.setAttribute("d", d);
      path.setAttribute("fill","none");
      path.setAttribute("stroke", stroke || "#fff");
      path.setAttribute("stroke-width","4");
      path.setAttribute("stroke-linecap","round");
      path.setAttribute("stroke-linejoin","round");
      svg.appendChild(path);
    }

    async function loadWeatherAndGraphs(){
      const wxMain = document.getElementById("wxMain");
      const wxSub  = document.getElementById("wxSub");

      try{
        const pointsUrl = `https://api.weather.gov/points/${LAT},${LON}`;
        const pointsRes = await fetch(pointsUrl, { headers: { "Accept":"application/geo+json" } });
        if(!pointsRes.ok) throw new Error(`points ${pointsRes.status}`);
        const points = await pointsRes.json();

        const hourlyUrl = points?.properties?.forecastHourly;
        if(!hourlyUrl) throw new Error("No forecastHourly URL returned");

        const hourlyRes = await fetch(hourlyUrl, { headers: { "Accept":"application/geo+json" } });
        if(!hourlyRes.ok) throw new Error(`hourly ${hourlyRes.status}`);
        const hourly = await hourlyRes.json();

        const periods = (hourly?.properties?.periods || []).slice(0, HOURS_TO_PLOT);
        const updated = hourly?.properties?.updated;
        if(periods.length === 0) throw new Error("No periods");

        const p0 = periods[0];
        const temp0 = `${p0.temperature}°${p0.temperatureUnit}`;
        const short0 = p0.shortForecast || "";
        const wind0 = (p0.windDirection && p0.windSpeed) ? `Wind ${p0.windDirection} ${p0.windSpeed}` : "";

        wxMain.textContent = `${temp0}  ${short0}`.trim();
        wxSub.textContent  = [
          wind0,
          updated ? `Updated ${new Date(updated).toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" })}` : ""
        ].filter(Boolean).join(" • ");

        const xLabels = periods.map(p => hourLabel(p.startTime));
        const temps = periods.map(p => Number.isFinite(p.temperature) ? p.temperature : null);
        const winds = periods.map(p => parseWindMph(p.windSpeed));
        const rains = periods.map(p => {
          const v = p?.probabilityOfPrecipitation?.value;
          return Number.isFinite(v) ? v : 0;
        });

        const start = new Date(periods[0].startTime).toLocaleTimeString([], { hour:"numeric" });
        const end = new Date(periods[periods.length-1].startTime).toLocaleTimeString([], { hour:"numeric" });

        document.getElementById("tempMeta").textContent = `${start}–${end}`;
        document.getElementById("windMeta").textContent = `${start}–${end}`;

        drawLineGraphWithAxes(document.getElementById("tempSvg"), temps, xLabels, "°", "#fff");
        drawLineGraphWithAxes(document.getElementById("windSvg"), winds, xLabels, "", "rgba(255,255,255,0.80)");

        const rainWrap = document.getElementById("rainWrap");
        const anyRain = rains.some(v => Number.isFinite(v) && v > 0);
        if(anyRain){
          rainWrap.style.display = "block";
          document.getElementById("rainMeta").textContent = `${start}–${end}`;
          drawLineGraphWithAxes(document.getElementById("rainSvg"), rains, xLabels, "%", "rgba(255,255,255,0.85)");
        }else{
          rainWrap.style.display = "none";
        }
      }catch(err){
        wxMain.textContent = "Weather unavailable";
        wxSub.textContent = "";
        console.error(err);
      }
    }

    // Init
    updateClock();
    setInterval(updateClock, 1000);

    loadWeatherAndGraphs();
    setInterval(loadWeatherAndGraphs, 2 * 60 * 1000);

    bustSatelliteCache();
    setInterval(bustSatelliteCache, 5 * 60 * 1000);

    setTimeout(() => location.reload(), REFRESH_MINUTES * 60 * 1000);
  </script>
</body>
</html>
